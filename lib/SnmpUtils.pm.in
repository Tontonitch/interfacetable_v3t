##############################################################################
# "SnmpUtils" library
# A collection of shared functions related to snmp.
#
# Version 0.03
# Written by Y. Charton, from extracts of check_interface_table 1-3 releases
#
# Revision history:
# 2011-06-08 v0.01   Y. Charton    First release
# 2011-12-30 v0.02   Y. Charton    Fusion of the get table functions
# 2012-05-02 v0.03   Y. Charton    Added transport domain selection and max-repetitions
#                                  (idea by Bjorn Frostberg), fix problem where 
#                                  empty snmp query result from cache was not used
#                                  and overwritten every time, better debug
#
##############################################################################

package SnmpUtils;
use strict;
use lib ('@libdir@');
use Exporter;
use GeneralUtils;

##############################################################################
### I N I T ##################################################################
##############################################################################

BEGIN {
    use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION $AUTHOR);
    @ISA         = qw(Exporter);
    @EXPORT      = qw(SnmpGet GetDataWithSnmp GetMultipleDataWithSnmp SnmpGetTable GetTableDataWithSnmp ExecuteCommand);
    @EXPORT_OK   = qw();
    $VERSION     = 0.03;
    $AUTHOR      = "Y. Charton";
}

##############################################################################
### S U B S ##################################################################
##############################################################################

#============================================================================#
# Single / one by one OID request via perl's netsnmp
#----------------------------------------------------------------------------#
# SnmpGet 
# GetDataWithSnmp 
# GetMultipleDataWithSnmp
#----------------------------------------------------------------------------#

sub SnmpGet {

    ################################
    # SUB use: 
    # SUB specs: 
    #  * arg 0:
    #  * return:
    ################################

    my $refhStruct = shift;

    #
    # store variables and delete them from the hash
    # this is necessary for the snmp session which takes the same
    # hash ref and does not work with arguments other than starting
    # with a dash
    #

    my $refaOIDs            = $refhStruct->{OID}; # ref to array of OIDs
    my $GlobalCacheDir      = $refhStruct->{CacheDir};
    my $GlobalCacheTimer    = $refhStruct->{CacheTimer};
    my $strict              = 0;
    
    delete $refhStruct->{OID};
    delete $refhStruct->{CacheDir};
    delete $refhStruct->{CacheTimer};

    my $refhSnmpValues; # hash returned to the caller
    my $refoSession;    # SNMP session object
    my $SessionError;   # SNMP session error
    
    # example cache dir name
    # /tmp/watchit/Cache/SnmpGet/cat-itd-01
    my $CacheDir = "$GlobalCacheDir/SnmpGet";

    # Create the directory if not existend
    not -d $CacheDir and MyMkdir($CacheDir);

    # create snmp session
    ($refoSession,$SessionError) = Net::SNMP->session (%$refhStruct);
    
    # check if any session establishment problem
    if (!defined $refoSession) {
      logger(0, "SNMP session establishment problem: ".$SessionError);
    }
    
    my $OIDLine;    # one line of OIDs or OIDs and caching timers
    my $SnmpValue;  # one snmp value

    if (defined $refoSession) {

        # OIDs come in an array (ref) - go through each
        # example:
        #    $refaOIDs = [
        #              '.1.3.6.1.2.1.2.2.1.11.1',
        #              '.1.3.6.1.2.1.2.2.1.12.1'
        #            ];
        for $OIDLine (@$refaOIDs) {

            my  $CacheTimer=0;

            $SnmpValue="";  # clear value

            # OID could be .1.3.6.1.2.1.2.2.1.11.1,200
            # <OID>,<CacheTimer> for this OID only
            my ($OID,$OIDCacheTimer) = ("","");
            ($OID,$OIDCacheTimer) = split ',',$OIDLine,2;

            if (defined $OIDCacheTimer) {
                # remove non digits
                $OIDCacheTimer =~ s/\D//g;
                if ("X$OIDCacheTimer" eq "X") { # is empty?
                    $CacheTimer = $GlobalCacheTimer;
                } else {
                    $CacheTimer = $OIDCacheTimer;
                }
            } else {
                $CacheTimer = $GlobalCacheTimer;
            }
            
            my $readFromCache = 0;
            if ($CacheTimer > 0) {
                if (-r "$CacheDir/$OID") {
                    logger(3, "Cached data file found: $CacheDir/$OID, cacheTimer=${CacheTimer}s");
                    my @FileProperties=stat("$CacheDir/$OID");

                    # $FileProperties[9] = LastModifyTime of file
                    # only read the cache file if it is not too old
                    if (time - $CacheTimer < $FileProperties[9]) {
                        logger(3, " valid cached data, loading");
                        open (IN,"<$CacheDir/$OID");
                            $SnmpValue = <IN>;
                        close (IN);
                        logger(3, "   data: \"$SnmpValue\"");
                        # leave this subroutine with cached data found
                        $readFromCache = 1;
                    } else {
                        logger(3, " expired cached data, skipping");
                    }
                }
            }
            
            unless (defined $SnmpValue) {$SnmpValue = "";}
            # snmp value not from cache - read it from the net
            if ($readFromCache == 0) {
                # get the snmp value - we do not check errors
                # here because of negative caching
                my $refhValue = $refoSession->get_request(-varbindlist => ["$OID"]);
                if (defined $refhValue->{"$OID"}) {
                    logger(3, "Data collected from net: OID=${OID}, value='$refhValue->{\"$OID\"}', cacheTimer=${CacheTimer}s");
                    $SnmpValue  =   $refhValue->{"$OID"};
                    
                    # remove non ascii chars incl. \r and \n
                    $SnmpValue  =~  s/[\000-\037]|[\177-\377]//g;

                    # replace ; with , - just to be sure
                    $SnmpValue  =~  s/;/,/g;

                    if ($CacheTimer > 0) {
                        logger(3, "Write cache file $CacheDir/$OID, CacheTimer=$CacheTimer");
                        umask "0000"; # change to rw-rw-rw maybe changed later because of security
                        open (OUT,">$CacheDir/$OID");
                            print OUT $SnmpValue;
                        close (OUT);
                    }
                }
                
            }
            
            # check result validity
            if ($SnmpValue =~ /noSuchObject/) {
                if ($strict == 0) {
                    # Replacing noSuchObject by an empty string.
                    # Indeed, the different snmp versions handle requests for missing oids 
                    # differently. v1 always returns an empty string. v2c/v3 return "noSuchObject" 
                    # string, and -translate noSuchObject -> '' correct that. BUt we do the change 
                    # to empty string after to be able to inform the user. Also, snmpwalk and other 
                    # unix programs don't have such a translate option.
                    # Ex: snmpwalk
                    # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                    # [icinga@server libexec]$
                    # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                    # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
                    # [icinga@server libexec]$
                    $SnmpValue = "";
                    logger(3, "Data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                } else {
                    logger(3, "Data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchObject'");
                }
            }
            if ($SnmpValue =~ /noSuchInstance/) {
                if ($strict == 0) {
                    # Replacing noSuchInstance by an empty string.
                    # Indeed, the different snmp versions handle requests for missing oids 
                    # differently. v1 always returns an empty string. v2c/v3 return "noSuchInstance" 
                    $SnmpValue = "";
                    logger(3, "Data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                } else {
                    logger(3, "Data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchInstance'");
                }
            }
            # fill hash with data
            $refhSnmpValues->{$OID}="$SnmpValue";
        }
        
        # if we have only 1 OID -> return the Value instead the hash
        if ($#$refaOIDs == 0) {
            return $SnmpValue;
        }
    }
    # return the complete hash with OIDs as keys or
    # undef if the SNMP session fails
    return $refhSnmpValues;
}

# ------------------------------------------------------------------------

sub GetDataWithSnmp {

    ################################
    # SUB use: Get Data with perl net-snmp module
    # SUB specs: 
    #  * arg 0: host
    #  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
    #  * return: value retrieved by snmp
    ################################

    my $host        = shift;
    my $refhSNMPOptions = shift;
    my $refaOID     = shift;    # ref to array of OIDs (numbers only)
    my $CacheDir    = shift;
    my $CacheTimer  = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $Value = "";
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            $Value = SnmpGet ({
                -hostname       => "$host",
                -port           => "$refhSNMPOptions->{'port'}",
                -domain         => "$refhSNMPOptions->{'domain'}",
                -version        => 3,
                -username       => "$refhSNMPOptions->{'login'}",
                -authpassword   => "$refhSNMPOptions->{'passwd'}",
                -authprotocol   => "$refhSNMPOptions->{'authproto'}",
                -privpassword   => "$refhSNMPOptions->{'privpass'}",
                -privprotocol   => "$refhSNMPOptions->{'privproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                -retries        => "$refhSNMPOptions->{'retries'}",
                -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching  
            });
        } else {
            $Value = SnmpGet ({
                -hostname       => "$host",
                -port           => "$refhSNMPOptions->{'port'}",
                -domain         => "$refhSNMPOptions->{'domain'}",
                -version        => 3,
                -username       => "$refhSNMPOptions->{'login'}",
                -authpassword   => "$refhSNMPOptions->{'passwd'}",
                -authprotocol   => "$refhSNMPOptions->{'authproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                -retries        => "$refhSNMPOptions->{'retries'}",
                -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching  
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        $Value = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 2,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -retries    => "$refhSNMPOptions->{'retries'}",
            -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching  
        });
    } else {
        $Value = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 1,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -retries    => "$refhSNMPOptions->{'retries'}",
            -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching  
        });
    }

    return ($Value);

}

# ------------------------------------------------------------------------

sub GetMultipleDataWithSnmp {

    ################################
    # SUB use: Get multiple Data with perl net-snmp module
    # SUB specs: 
    #  * arg 0: host
    #  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
    #  * return: hash of values retrieved by snmp
    ################################

    my $host        = shift;
    my $refhSNMPOptions = shift;
    my $refaOID     = shift;    # ref to array of OIDs (numbers only)
    my $CacheDir    = shift;
    my $CacheTimer  = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $refhSNMP    = ();
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            $refhSNMP = SnmpGet ({
                -hostname   => "$host",
                -port       => "$refhSNMPOptions->{'port'}",
                -domain     => "$refhSNMPOptions->{'domain'}",
                -version    => 3,
                -username       => "$refhSNMPOptions->{'login'}",
                -authpassword   => "$refhSNMPOptions->{'passwd'}",
                -authprotocol   => "$refhSNMPOptions->{'authproto'}",
                -privpassword   => "$refhSNMPOptions->{'privpass'}",
                -privprotocol   => "$refhSNMPOptions->{'privproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                -retries        => "$refhSNMPOptions->{'retries'}",
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching
            });
        } else {
            $refhSNMP = SnmpGet ({
                -hostname   => "$host",
                -port       => "$refhSNMPOptions->{'port'}",
                -domain     => "$refhSNMPOptions->{'domain'}",
                -version    => 3,
                -username       => "$refhSNMPOptions->{'login'}",
                -authpassword   => "$refhSNMPOptions->{'passwd'}",
                -authprotocol   => "$refhSNMPOptions->{'authproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                -retries        => "$refhSNMPOptions->{'retries'}",
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        $refhSNMP = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 2,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -retries    => "$refhSNMPOptions->{'retries'}",
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        });
    } else {
        $refhSNMP = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 1,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -retries    => "$refhSNMPOptions->{'retries'}",
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        });
    }
    
    return ($refhSNMP);
}

#============================================================================#
# Table OID request via perl's netsnmp or unix snmpwalk/snmpbulkwalk
#----------------------------------------------------------------------------#
# SnmpGetTable 
#  
#----------------------------------------------------------------------------#

sub SnmpGetTable {

    ################################
    # SUB use: 
    # SUB specs: 
    #  * arg 0:
    #  * return:
    ################################

    my $refhStruct = shift;

    #
    # store variables and delete them from the hash
    # this is necessary for the snmp session which takes the same
    # hash ref and does not work with arguments other than starting
    # with a dash
    #

    my $OIDLine             = $refhStruct->{OID};
    my $GlobalCacheDir      = $refhStruct->{CacheDir};
    my $GlobalCacheTimer    = $refhStruct->{CacheTimer};
    my $strict              = 0;
    
    delete $refhStruct->{OID};
    delete $refhStruct->{CacheDir};
    delete $refhStruct->{CacheTimer};

    my $refhSnmpValues; # hash returned to the caller
    my $refoSession;    # SNMP session object
    my $SessionError;   # SNMP session error
    
    my $refhQuery = ();
    if (defined $refhStruct->{'-maxrepetitions'}) {
        $refhQuery->{'-maxrepetitions'} = $refhStruct->{'-maxrepetitions'};
        delete $refhStruct->{'-maxrepetitions'};
    }
    
    my $refaLines=[];   # Pointer to Array of strings (output)
    
    # example cache dir name
    # /tmp/watchit/Cache/SnmpGet/cat-itd-01
    my $CacheDir = "$GlobalCacheDir/SnmpGetTable";

    # Create the directory if not existend
    not -d $CacheDir and MyMkdir($CacheDir);

    # create snmp session
    ($refoSession,$SessionError) = Net::SNMP->session (%$refhStruct);
    
    # check if any session establishment problem
    if (!defined $refoSession) {
      logger(0, "SNMP session establishment problem: ".$SessionError);
    }
    
    if (defined $refoSession) {

        # OIDs come in an array (ref) - go through each
        # example:
        #    $refaOIDs = [
        #              '.1.3.6.1.2.1.2.2.1.11.1',
        #              '.1.3.6.1.2.1.2.2.1.12.1'
        #            ];
        
        my  $CacheTimer=0;

        # OID could be .1.3.6.1.2.1.2.2.1.11.1,200
        # <OID>,<CacheTimer> for this OID only
        my ($OID,$OIDCacheTimer) = ("","");
        ($OID,$OIDCacheTimer) = split ',',$OIDLine,2;
        $refhQuery->{'-baseoid'} = "$OID";
        
        if (defined $OIDCacheTimer) {
            # remove non digits
            $OIDCacheTimer =~ s/\D//g;
            if ("X$OIDCacheTimer" eq "X") { # is empty?
                $CacheTimer = $GlobalCacheTimer;
            } else {
                $CacheTimer = $OIDCacheTimer;
            }
        } else {
            $CacheTimer = $GlobalCacheTimer;
        }

        my $readFromCache = 0;
        if ($CacheTimer > 0) {
            if (-r "$CacheDir/$OID") {
                logger(3, "Cached data file found: $CacheDir/$OID, cacheTimer=${CacheTimer}s");
                my @FileProperties=stat("$CacheDir/$OID");

                # $FileProperties[9] = LastModifyTime of file
                # only read the cache file if it is not too old
                if (time - $CacheTimer < $FileProperties[9]) {
                    logger(3, " valid cached data, loading");
                    open (IN,"<$CacheDir/$OID");
                        @$refaLines = <IN>;
                    close (IN);
                    foreach (@$refaLines) {
                        $_ =~ s/\n$//g;
                        logger(3, "   data: $_");
                    }
                    # leave this subroutine with cached data found
                    $readFromCache = 1;
                } else {
                    logger(3, " expired cached data, skipping");
                }
            }
        }
        # snmp value not from cache - read it from the net
        if ($readFromCache == 0) {
            logger(3, "Data collected from net: base-OID=${OID}, cacheTimer=${CacheTimer}s");
            my $refhValues = $refoSession->get_table(%$refhQuery);
            foreach my $k (keys(%{$refhValues})) {
                logger(3, " OID=$k, value='$refhValues->{$k}'");
                my $SnmpValue = $refhValues->{$k};
                
                # remove non ascii chars incl. \r and \n
                $SnmpValue  =~  s/[\000-\037]|[\177-\377]//g;
                
                # replace ; with , - just to be sure
                $SnmpValue  =~  s/;/,/g;
                
                # check result validity
                if ($SnmpValue =~ /noSuchObject/) {
                    if ($strict == 0) {
                        # Replacing noSuchObject by an empty string.
                        # Indeed, the different snmp versions handle requests for missing oids 
                        # differently. v1 always returns an empty string. v2c/v3 return "noSuchObject" 
                        # string, and -translate noSuchObject -> '' correct that. BUt we do the change 
                        # to empty string after to be able to inform the user. Also, snmpwalk and other 
                        # unix programs don't have such a translate option.
                        # Ex: snmpwalk
                        # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                        # [icinga@server libexec]$
                        # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                        # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
                        # [icinga@server libexec]$
                        $SnmpValue = "";
                        logger(3, "Data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                    } else {
                        logger(3, "Data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchObject'");
                    }
                }
                if ($SnmpValue =~ /noSuchInstance/) {
                    if ($strict == 0) {
                        # Replacing noSuchInstance by an empty string.
                        # Indeed, the different snmp versions handle requests for missing oids 
                        # differently. v1 always returns an empty string. v2c/v3 return "noSuchInstance" 
                        $SnmpValue = "";
                        logger(3, "Data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                    } else {
                        logger(3, "Data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchInstance'");
                    }
                }
                
                # fill result array with data
                push @$refaLines,"$k $SnmpValue";
            }
            # write a cache file if the cache timer > 0
            if ($CacheTimer > 0) {
                logger(3, "Write cache file $CacheDir/$OID, CacheTimer=$CacheTimer");
                umask "0000"; # change to rw-rw-rw maybe changed later because of security
                open (OUT,">$CacheDir/$OID");
                foreach my $line (@$refaLines) {
                        print OUT "$line\n";
                }
                close (OUT);
            }
        }
    }
    return $refaLines;
}

#----------------------------------------------------------------------------#

sub GetTableDataWithSnmp {

    ################################
    # SUB use: Get multiple Data with perl net-snmp module
    #          or unix snmpwalk/snmpbulkwalk
    # SUB specs: 
    #  * arg 0: host
    #  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
    #  * return: hash of values retrieved by snmp
    ################################

    my $host            = shift;
    my $refhSNMPOptions = shift;
    my $OID             = shift;    # only one OID (number or name)
    my $CacheDir        = shift;
    my $CacheTimer      = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $strict          = 0;
    my $refaLinesTmp    = ();
    my $refaLines       = ();
    
    
    if ( not $refhSNMPOptions->{'unixsnmp'} ) {
        # gather data via perl's snmp  
        my %refhSnmpQueryOptions = (
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -version    => "$refhSNMPOptions->{'version'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -retries    => "$refhSNMPOptions->{'retries'}",
            OID         => $OID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching;
        );
        if ( $refhSNMPOptions->{'version'} eq 3 ) {
            $refhSnmpQueryOptions{'-username'}     = "$refhSNMPOptions->{'login'}";
            $refhSnmpQueryOptions{'-authpassword'} = "$refhSNMPOptions->{'passwd'}";
            $refhSnmpQueryOptions{'-authprotocol'} = "$refhSNMPOptions->{'authproto'}";
            if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
                $refhSnmpQueryOptions{'-privpassword'} = "$refhSNMPOptions->{'privpass'}";
                $refhSnmpQueryOptions{'-privprotocol'} = "$refhSNMPOptions->{'privproto'}";
            }
            defined $refhSNMPOptions->{'max-repetitions'} and $refhSnmpQueryOptions{'-maxrepetitions'} = "$refhSNMPOptions->{'max-repetitions'}";
        } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
            $refhSnmpQueryOptions{'-community'} = "$refhSNMPOptions->{'community'}";
            defined $refhSNMPOptions->{'max-repetitions'} and $refhSnmpQueryOptions{'-maxrepetitions'} = "$refhSNMPOptions->{'max-repetitions'}";
        } else {
            $refhSnmpQueryOptions{'-community'} = "$refhSNMPOptions->{'community'}";
        }
        ($refaLines) = SnmpGetTable (\%refhSnmpQueryOptions);
    } else {
        # gather data via unix snmpwalk/snmpbulkwalk
        my $refhSnmpQueryCommand = "snmpbulkwalk"; 
        my $refhSnmpQueryOptions = "-Oqn -t $refhSNMPOptions->{'timeout'} -r $refhSNMPOptions->{'retries'} ";
        $refhSnmpQueryOptions .= ($refhSNMPOptions->{'version'} == 2) ? "-v 2c " : "-v $refhSNMPOptions->{'version'} ";
        if ( $refhSNMPOptions->{'version'} eq 3 ) {
            if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
                $refhSnmpQueryOptions .= "-u $refhSNMPOptions->{'login'} -l authPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} -X $refhSNMPOptions->{'privpass'} -x $refhSNMPOptions->{'privproto'} ";
            } else {
                $refhSnmpQueryOptions .= "-u $refhSNMPOptions->{'login'} -l authNoPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} "
            }
            defined $refhSNMPOptions->{'max-repetitions'} and $refhSnmpQueryOptions .= "-Cr$refhSNMPOptions->{'max-repetitions'} ";
        } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
            $refhSnmpQueryOptions .= "-c $refhSNMPOptions->{'community'} ";
            defined $refhSNMPOptions->{'max-repetitions'} and $refhSnmpQueryOptions .= "-Cr$refhSNMPOptions->{'max-repetitions'} ";
        } else {
            $refhSnmpQueryCommand = "snmpwalk"; 
            $refhSnmpQueryOptions .= "-c $refhSNMPOptions->{'community'} ";
        }
        ($refaLinesTmp) = ExecuteCommand ({
            Command     => "$refhSnmpQueryCommand $refhSnmpQueryOptions $refhSNMPOptions->{'domain'}:${host}:$refhSNMPOptions->{'port'} $OID",
            Retry       => 2,
            CacheDir    => $CacheDir,
            CacheTimer  => int rand ($CacheTimer),
        });
            
        # check result validity
        foreach my $line ( @$refaLinesTmp ) {
            if ($line =~ /No Such Object available on this agent at this OID/) {
                if ($strict == 0) {
                    # Replacing noSuchObject by an empty string.
                    # Indeed, the different snmp versions handle requests for missing oids 
                    # differently. While v1 returns an empty string, v2c/v3 return "noSuchObject" 
                    # string
                    # Ex: snmpwalk
                    # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                    # [icinga@server libexec]$
                    # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                    # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
                    # [icinga@server libexec]$
                    logger(2, "Data validity check: $line, no such objet in the mib. Strict mode disabled, returning an empty array");
                    return $refaLines;
                } else {
                    push(@$refaLines, $line);
                    logger(2, "Data validity check: $line, no such objet in the mib. Strict mode enabled, keeping '$line'");
                }
            } else {
                push(@$refaLines, $line);
            }
        }    
    }
    
    return $refaLines;
}


#============================================================================#
# Other functions
#----------------------------------------------------------------------------#
# ExecuteCommand 
#----------------------------------------------------------------------------#

# ------------------------------------------------------------------------
# ExecuteCommand Routine. Enhanced with our cache algorith...

sub ExecuteCommand {
    my $refhStruct      = shift;
    my $Command         = $refhStruct->{Command};
    my $GlobalCacheDir  = $refhStruct->{CacheDir};

    my $refaLines=[];   # Pointer to Array of strings (output)

    my $CacheFile;      # Filename storing cached data
    my $ExitCode;       # exit code of the unix command

    my $Now=time();     # current time in seconds since epoch

    my $CacheDir="$GlobalCacheDir/ExecuteCommand/"; # cache dir

    # Create Cachedir if not existend
    not -d $CacheDir and MyMkdir($CacheDir);

    # If caching for this command is enabled
    if ($refhStruct->{CacheTimer} > 0) {
        $CacheFile = $CacheDir . normalize ("$Command");
        if (-r "$CacheFile") {
            logger(3, "Cached data file found: $CacheFile, cacheTimer=$refhStruct->{CacheTimer}s");
            my @FileProperties=stat($CacheFile);

            # $FileProperties[9] = LastModifyTime of file
            # only read the cache file if it is not too old
            if ($Now-$refhStruct->{CacheTimer} < $FileProperties[9]) {
                logger(3, " valid cached data, loading");
                open (IN,"<$CacheFile");
                    @$refaLines=<IN>;
                close (IN);
                foreach (@$refaLines) {
                    $_ =~ s/\n$//g;
                    logger(3, "   data: $_");
                }
                # leave this subroutine with cached data found
                return ($refaLines,0);
            } else {
                logger(3, " expired cached data, skipping");
            }
        }
    }

    # execute the unix command
    open(UNIX,"$Command |") or die "[ERROR] Failed to execute \"$Command\", $!";
        while (<UNIX>) {
            push @$refaLines,$_;
        }
    close(UNIX);
    $ExitCode=$? >> 8; # calculate the exit code
    logger(3, "Executed \"$Command\" and got ExitCode \"$ExitCode\"");

    # stop in case of error
    if ($ExitCode != 0) {
        logger(0, "The UNIX command \"$Command\" returned the ExitCode \"$ExitCode\"");
        exit 1;
    }
    
    # write a cache file if the cache timer > 0
    if ($refhStruct->{CacheTimer} > 0) {
        logger(3, "Write cache file $CacheFile, CacheTimer=$refhStruct->{CacheTimer}");
        umask "0000"; # change to rw-rw-rw maybe changed later because of security
        open (OUT,">$CacheFile") or return ($refaLines,$ExitCode);
            print OUT @$refaLines;
        close (OUT);
    }
    return ($refaLines,$ExitCode);
}

1;

__END__

# vi: set ts=4 sw=4 expandtab :
