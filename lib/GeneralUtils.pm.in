##############################################################################
# "GeneralUtils" library
# A collection of shared functions for general usage.
#
# Version 0.1
# Written by Y. Charton, extracts some libraries of Nconf and NagiosBp
#
# Revision history:
# 2011-06-08 v0.1   Y. Charton    First release
#
##############################################################################

package GeneralUtils;
use strict;
use lib ('@libdir@');
use Exporter;

use vars qw($LOGLEVEL);
$LOGLEVEL = 0;

##############################################################################
### I N I T ##################################################################
##############################################################################

BEGIN {
    use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION $AUTHOR);
    @ISA         = qw(Exporter);
    @EXPORT      = qw(setLoglevel logger printArray printHash fixedLen cutOffSpaces getHostnameFromUrl getProtocolFromUrl MyMkdir normalize denormalize trim);
    @EXPORT_OK   = qw();
    $VERSION     = 0.1;
    $AUTHOR      = "Y. Charton";
}

##############################################################################
### S U B S ##################################################################
##############################################################################

sub setLoglevel {

    ################################
    # SUB use: Set the overall loglevel
    # SUB specs: ###################
    #  * arg 0: The loglevel to set (1-3)
    ################################

    my $loglevel = shift;
    if($loglevel >= 1 && $loglevel <= 3){
        $LOGLEVEL = $loglevel;
    }
}

#----------------------------------------------------------------------------#

sub logger {

    ################################
    # SUB use: Log and display messages based on loglevel
    # SUB specs:
    #  * arg 0: The loglevel of the message (0-3)
    #  * arg 1: The message to be logged
    #  * return: nothing (all is printed to STDOUT)
    ################################
    # loglevel - message category
    #        0 - criticals
    #        1 - information 
    #        1 - warnings
    #        2 - calculations
    #        2 - html output
    #        2 - performance data output
    #        2 - snmp queries/results
    #        3 - executecommand
    #        3 - commandline
    #        3 - config file
    #        3 - options
    #        3 - history file content
    #        3 - current status    
    ################################

    my $loglevel = 0;
    my $msg      = undef;

    $loglevel    = shift;
    $msg         = shift;

    unless($loglevel >= 0 and $loglevel <= 3){die "You passed a message with an invalid loglevel lo logger().\n"}
    unless($LOGLEVEL >= 0 and $LOGLEVEL <= 3){die "The main loglevel is not set properly (must be 0-3).\n"}

    # define labels for different loglevels
    my %level_labels = ( 0 => "ERROR", 1 => "INFO", 2 => "DEBUG", 3 => "TRACE" );

    # fetch the name of the function which called logger()
    my $caller = (caller(1))[3];
    if($caller){
        $caller="|".$caller."| ";
    }else{
        $caller="|main| ";
    }

    # printing the message depending on the debug level
    if($loglevel <= $LOGLEVEL){
        my $space = "";
        if(length($level_labels{$loglevel}) == 4){$space=" "}
        # show the calling function, if loglevel is higher than 2
        if($LOGLEVEL >= 2){
            print "[$level_labels{$loglevel}]$space $caller";
        }else{
            print "[$level_labels{$loglevel}]$space ";

        }
        print $msg,"\n";
    }
}


=head1 NAME

 GeneralUtils - Some functions quite often used

=head1 SYNOPSIS

	use GeneralUtils;

	printArray(\@a);
	printArray(\@a, "DEBUG: ");

	printHash(\%h);
	printHash(\%h, "    ");  # e. g. if you want to print intended
	
	print fixedLen("aVeryLongStringWithoutAnySpace", 20, "right") . "\n";
	# prints out: aVeryLongStringWitho
	
	$c = "short";
	$c = fixedLen($c, 20, undef, ".");
	# $c is now: short...............

	$string = cutOffSpaces("foo   ");
	# $string = "foo"

	$hostname = getHostnameFromUrl("http://www.example.com:80/foo/");
	# $hostname = "www.example.com";
	$hostname = getHostnameFromUrl("http://myworkstation.example.com", "s");
	# $hostname = "myworkstation";

	print getProtocolFromUrl("https://www.example.com/test/") ."\n";
	# https
	$p = getProtocolFromUrl("www.example.com");
	# $p = "http";

=head1 DESCRIPTION

=head2 GeneralUtils::printArray 

	GeneralUtils::printArray(\@array [, $prefix])
	
	prints out the content of an array in a structured way
	
	parameter 1: reference to an array
	parameter 2: prefix for every line of output
	returns:     nothing of value

=cut

#----------------------------------------------------------------------------#

sub printArray
{
    my $array = shift;
    my $prefix = shift;
    my $output = "";
    my ($i, $len);
	
	if (defined $array) {
        $len=length(@$array - 1);
        #$output = $output . "len: $len";
        for ($i=0; $i<@$array; $i++)
        {
            $i = sprintf("%0${len}d", $i);
            if ($output ne "") {
                $output = $output . '\n';
            }
            $output = $output . "${prefix}[$i]: $array->[$i]";
        }
    }
    return $output;
}

=head2 GeneralUtils::printHash

	GeneralUtils::printHash(\%hash [, $prefix])
	
	prints out the content of a hash in a structured way
	
	parameter 1: reference to a hash
	parameter 2: prefix for every line of output
	returns:     nothing of value

=cut

#----------------------------------------------------------------------------#

sub printHash
{
	my $hash = shift;
	my $prefix = shift || "";
    my $output = "";
	my ($key);
	my $maxlen = 0;

	if(defined $hash) {
        foreach $key (keys %$hash)
        {
            if (length($key) > $maxlen)
            {
                $maxlen = length($key);
            }
        }
        #$output = $output . "max: $maxlen\n";
        foreach $key (keys %$hash)
        {
            if ($output ne "") {
                $output = $output . '\n';
            }
            $output = $output . "${prefix}" . fixedLen("[$key]", $maxlen+2, "left") . " => $hash->{$key}";
        }
    }
    return $output;
}

# ------------------------------------------------------------------------

sub fixedLen {

    ################################
    # SUB use: GeneralUtils::fixedLen($string [, $len [, "left"|"right" [, $fillchar]]])
	#          brings a given string to a fixed length and returns the string afterwards
	#          no matter if it is shorter or longer before
    # SUB specs:
    #  * arg 0: the string
    #  * arg 1: the desired length (integer), defaults to 10 if omitted
    #  * arg 2: "left" or "right": tells on which side blanks are appended or characters are cut off
    #  * arg 3: fillcharacter: 1 character, which should be used to fill up short strings
	#           defaults to blank " "
	#  * return: the resulting string
    ################################

	my $string = shift;
	my $len = shift || 10;
	my $side = shift || "right";
	my $fillchar = shift || " ";
	my $fillstring;
	
	if (length($string) > $len)
	{
		if ($side eq "left")
		{
			$string = substr($string, $len*(-1));
		}
		else
		{
			$string = substr($string, 0, $len);
		}
	}
	if (length($string) < $len)
	{
		$fillchar = substr($fillchar, 0, 1);
		$fillstring = $fillchar x ($len-length($string));
		if ($side eq "left")
		{
			$string = $fillstring . $string;
		}
		else
		{
			$string .= $fillstring;
		}
	}
	
	return $string;
}

# ------------------------------------------------------------------------

sub cutOffSpaces {

    ################################
    # SUB use: cuts of leading and trailing whitespace characters of a given string
    # SUB specs:
    #  * arg 0: the string
	#  * return: the resulting string
    ################################

	my $string = shift;
	$string =~ s/^\s*//;
	$string =~ s/\s*$//;
	# does the same as the two lines above, but takes twice as long
	#$string =~ s/^\s*(.*?)\s*$/$1/;
    return ($string);
}

# ------------------------------------------------------------------------

sub getHostnameFromUrl {

    ################################
    # SUB use: from a given URL, we extract the hostname
	#          give "s" as second parameter to get the short hostname (everything before the first dot)
	#          give "l" or leave empty, to get the full qualified hostname, if it is in the URL as full qualified name
    # SUB specs:
    #  * arg 0: the URL
    #  * arg 1: the return modifier
	#  * return: the hostname as string
    ################################

	my $url = shift;
	my $switch = shift;

	if ($switch eq "s")
	{
		# if an IP is used instead a hostname there is no sense in cutting after the first dot
		if ($url =~ m/^(.+:\/\/)?(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/)
		{
			if (defined($2))
			{
				return($2);
			}
			else
			{
				return($1);
			}
		}

		$url =~ m/^(.+:\/\/)?([^.:\/]+)/;
		if (defined($2))
		{
			return($2);
		}
		else
		{
			return($1);
		}
	}
	else
	{
		$url =~ m/^(.+:\/\/)?([^:\/]+)/;
		if (defined($2))
		{
			return($2);
		}
		else
		{
			return($1);
		}
	}
	return(undef);
}

# ------------------------------------------------------------------------

sub getProtocolFromUrl {

    ################################
    # SUB use: From a given URL, we extract the protocol
    # SUB specs:
    #  * arg 0: the URL
    #  * arg 1: The message to be logged
	#  * return: the protocol as string
    ################################

	my $url = shift;
	$url =~ m/^(.+):\/\//;
	if (defined($1))
	{
		return($1);
	}
	else
	{
		return("http");
	}
}

# ------------------------------------------------------------------------
# dir creator extracted from our FileOperations library

sub MyMkdir {

    my  $Directory = shift;

    $Directory  =~  s/\s//g;    # remove invisible characters
    $Directory  =~  s/\\/\//g;  # replace \ with /
    $Directory  =~  s/\/+/\//g; # replace duplicate or more slashes with one /

    # split directory into pieces
    my @Dirs    =   split /\//,$Directory;

    # growing directory structure
    my $Snake = "";

    # walk through each directory and create it
    for my $Dir (@Dirs) {
        $Snake .= $Dir.'/';
        if (not -d "$Snake") {
            umask "0000";
            my $Success = mkdir $Snake;
            if ("$Success" ne "1") {
                undef $Snake;
                last;
            }
        }
    }

    # remove last / and return the directory back to the caller
    if ($Snake) {
            if ("$Snake" =~ /\/$/) {
            chop ($Snake);
        }
        }
    return $Snake;
}

# ------------------------------------------------------------------------
# normalize and denormalize subroutines
# - used to get rid of special characters

sub normalize {
    my $Text=shift;
    $Text=~s/Q/Q51/g;                                                                                   # Q normalisieren
    $Text=~s/[\000-\017]/sprintf ("Q0%X",ord($&))/ge;                   # einstellige HEX Zahlen mit 0 davor konvertieren
    $Text=~s/[\W_]/sprintf ("Q%X",ord($&))/ge;                                  # alle anderen Zeichen durch Q + HEX code ersetzen
    return $Text;                                                                                               # fertig
}

# ------------------------------------------------------------------------
# normalize and denormalize subroutines
# - used to get rid of special characters

sub denormalize {
    my $Text=shift;
    $Text=~s/Q../pack "H2",substr($&,1,3)/ge;
    return $Text;
}

# ------------------------------------------------------------------------
# trim function to remove whitespace from the start and end of the string

sub trim {
    my @out = @_;
    for (@out) {
        s/^\s+//;
        s/\s+$//;
    }
    return wantarray ? @out : $out[0];
}

1;

__END__